/* Firmware to be run on the microcontroller in the sensor organ
 *  
 *  From the pi (master) point of view, the i2c registers available are:
 *  0x01: request time-of-flight reading. This will return two byte (16bits) value that is the measured distance in mm.
 *  0x01: request infrared reading. This returns the latest value of the beacon detection system (described below).
 * 
 * Beacon detection is done by infrared sensor, i.e. from an analogue input voltage generated by a phototransistor driving a load resistor
 * Technically, the detected infrared produces a drop in this analogue voltage, so lower voltage means stronger IR signal
 * However, the output of the detector code is differential, so higher output means higher signal
 * Incoming ADC samples of the voltage are pushed into a FIFO buffer which acts as a moving-average window. Longer window = smoother signal, but longer time delay
 * Contents of the window are dynamically divided into 'low' and 'high' groups before being averaged, hence accounting for background IR radiation
 * The subtraction of the 'high' average from the 'low' average produces the output of the detector.
 * This exploits the 600Hz on-off switching of the beacon, but in principle is valid for any switching frequency.
 * It is essential, however, that the sampling frequency _not_ be an exact divisor of 600Hz, e.g. 200Hz
 * Ideally it would have a prime mathematical relationship with the beacon frequency, but as long as it avoids being an exact divisor or close to one, it should be fine.
 * (I'm not exactly an expert on this, but this is my basic understanding)
 * 
 * Author: Mike Angus, Matt Hale
*/

#include <Wire.h>
#include <VL53L0X.h>
VL53L0X timeOfFlightSensor;

#define SLAVE_ADDRESS 0x3E // <=== THIS NEEDS TO BE SET FOR EACH UNIQUE ORGAN

// debugging flags:
//#define SERIAL_DEBUG_PRINTING
//#define SERIAL_DEBUG_FILTERING_RAW_DATA
//#define SERIAL_DEBUG_IR_SENSOR

// define register addresses this slave device provides
#define REQUEST_TIME_OF_FLIGHT_REGISTER 0x01 // depricated
#define REQUEST_INFRARED_REGISTER 0x02
#define FLASH_INDICATOR_LED_REGISTER 0x03
#define SET_TIME_OF_FLIGHT_ADDRESS_REGISTER 0x04 // set the i2c address of the VL53L0X sensor
#define GET_TIME_OF_FLIGHT_ADDRESS_REGISTER 0x05 // return what the arduino thinks is the i2c address of the VL53L0X sensor
#define REQUEST_INFRARED_RAW_VALUE_REGISTER 0x06 // return the raw IR value, without the filtering
#define SET_TEST_VALUE_REGISTER 0x90 // save a given value
#define GET_TEST_VALUE_REGISTER 0x91 // return the saved value

// define pins:
#define INDICATOR_LED_PIN 9
#define IR_MEASURE_PIN 7
#define PIN_I2CENABLE 15

// define sensor filtering parameters
#define LOOP_TIME_US 5668 // the time (in microseconds) between taking samples. Must NOT be an integer multiple of the time between flashes of the beacon. E.g., beacon is 600Hz->1667us, we choose 5668us (176Hz) which is a multiple of 3.4
#define IR_WINDOW_SIZE 64 //Window size _must_ be a power of two: 2,4,8,16,32,64,128,256 etc
#define IR_WINDOW_WRAPPING_BITMASK (IR_WINDOW_SIZE - 1)
#define IR_MAX_DIFFERENTIAL_READING 400 //Max output seen from the IR sensor, obtained by observation

//define other constants
#define LED_FLASH_HALF_TIMEPERIOD 500000 // the time between the LED coming on and going off (and vice versa) when flashes are requested, in microseconds
#define TIME_OF_FLIGHT_SENSOR_HARDWARE_DEFAULT_ADDRESS 0x29
#define VL53L0X_CHANGE_ADDRESS_REGISTER 0x8A // VL53L0X Register for change i2c address, from https://community.st.com/s/question/0D50X00009XkYG8/vl53l0x-register-map

// flags and global variables:
unsigned long loop_target_end_time;
bool time_of_flight_value_is_requested = false;
bool infrared_value_is_requested = false;
bool raw_IR_value_is_requested = false;
bool TOF_address_is_requested = false;
uint8_t input_buffer[2];
uint8_t send_buffer;
bool first_byte_has_been_sent=false;
uint16_t reading; // variable to store the reading to be sent back to master
unsigned int number_of_flashes_requested = 0;
unsigned long time_of_previous_led_flash =0;
bool led_is_on = false;
uint8_t test_register_value = 0;
bool test_resgister_is_requested = false;
int current_filtered_beacon_level =0; //recalculated from new readings each timestep

bool new_address_for_time_of_flight_sensor_received = false;
int new_address_of_time_of_flight_sensor = TIME_OF_FLIGHT_SENSOR_HARDWARE_DEFAULT_ADDRESS;
int current_address_of_time_of_flight_sensor = TIME_OF_FLIGHT_SENSOR_HARDWARE_DEFAULT_ADDRESS; // don't worry, this gets chenged in setup()

//Fast FIFO buffer stuff:
typedef struct FIFO
{
	int buf[IR_WINDOW_SIZE];
	unsigned int index;
}FIFO;
//Function prototypes
void fifoWrite(FIFO* fifo, int value, int wrappingBitmask);
int fifoReadOffset(FIFO* fifo, int indexOffset, int wrappingBitmask);
int getBeaconLevel(FIFO* samplingWindow, int windowSize, int wrappingBitmask);
//FIFO buffer for IR beacon windowing
FIFO irWindow;

//Setup function
void setup() {
  // set the pin modes
  pinMode(INDICATOR_LED_PIN, OUTPUT);
  digitalWrite(INDICATOR_LED_PIN,LOW);
  pinMode(PIN_I2CENABLE, OUTPUT);
  digitalWrite(PIN_I2CENABLE, HIGH); // close i2c to outside world

  Serial.begin(115200); //formerly 2000000
  Serial.println("Sensor Organ Reporting");
  
  // start i2c comms
  Wire.begin(SLAVE_ADDRESS);
  Wire.onReceive(receiveData);
  Wire.onRequest(sendData);

  
  // set up the time of flight sensor:
  timeOfFlightSensor.setTimeout(500);
  #ifdef SERIAL_DEBUG_PRINTING
    Serial.println("Setting up timeOfFlightSensor");
  #endif
  if (!timeOfFlightSensor.init())
  {
    #ifdef SERIAL_DEBUG_PRINTING
      Serial.println("Failed to detect and initialize sensor!");
    #endif
  }

  // set to "long range":
  timeOfFlightSensor.setSignalRateLimit(0.1); // lower the return signal rate limit (default is 0.25 MCPS)
  timeOfFlightSensor.setVcselPulsePeriod(VL53L0X::VcselPeriodPreRange, 18);// increase laser pulse periods (defaults are 14 and 10 PCLKs)
  timeOfFlightSensor.setVcselPulsePeriod(VL53L0X::VcselPeriodFinalRange, 14);

  #ifdef SERIAL_DEBUG_PRINTING
    Serial.println("Starting timeOfFlightSensor");
  #endif
  
  timeOfFlightSensor.startContinuous();
  timeOfFlightSensor.setAddress(SLAVE_ADDRESS+1);
  digitalWrite(PIN_I2CENABLE, LOW); // open i2c to outside world
  
  // prepare for loop start
  loop_target_end_time = micros()+LOOP_TIME_US;

  #ifdef SERIAL_DEBUG_PRINTING
    Serial.println("Starting");
  #endif
  
} // end of setup()


//Main loop
void loop() {

  // wait until it is time for next loop
  unsigned long time_now = micros();
  if (time_now>=loop_target_end_time){ // it's time to put another IR reading into the buffer
    loop_target_end_time += LOOP_TIME_US; // the next time this part will be executed
    if (time_now > loop_target_end_time){// can't keep up
      #ifdef SERIAL_DEBUG_PRINTING
        Serial.println("can't keep up");
      #endif
      loop_target_end_time = time_now+LOOP_TIME_US; // to stop us falling ever further behind
    } 
    
    //Read IR measurement and add to the FIFO buffer that is the measurement window
    int value = analogRead(IR_MEASURE_PIN);
    fifoWrite(&irWindow, value, IR_WINDOW_WRAPPING_BITMASK);

    //Calculate a new reading
    current_filtered_beacon_level = getBeaconLevel(&irWindow, IR_WINDOW_SIZE, IR_WINDOW_WRAPPING_BITMASK);

    #ifdef SERIAL_DEBUG_IR_SENSOR
//      Serial.print("Filtered beacon reading: ");
      Serial.println(current_filtered_beacon_level);
    #endif

    //Indicate beacon reading on the LED
    analogWrite(INDICATOR_LED_PIN, current_filtered_beacon_level);
  }

  // is it time to turn the LED on or off?
  if (number_of_flashes_requested > 0 && time_of_previous_led_flash<time_now - LED_FLASH_HALF_TIMEPERIOD){
    if(led_is_on){
      digitalWrite(INDICATOR_LED_PIN,LOW);
      led_is_on=false;
      number_of_flashes_requested -= 1; // decrement after turning off so we always end in the off state
      }else{
      digitalWrite(INDICATOR_LED_PIN,HIGH);
      led_is_on=true;
    }
    time_of_previous_led_flash = time_now;
  }

  if (new_address_for_time_of_flight_sensor_received){
    new_address_for_time_of_flight_sensor_received=false;
    timeOfFlightSensor.setAddress(new_address_of_time_of_flight_sensor & 0x7F);
  }
}
