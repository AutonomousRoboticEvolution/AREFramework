/*
 * Code for beacon detection from an analogue input voltage (generated by a phototransistor driving a load resistor)
 * 
 * Technically, the detected infrared produces a drop in this analogue voltage, so lower voltage means stronger IR signal
 * However, the output of the detector code is differential, so higher output means higher signal
 * 
 * Incoming ADC samples of the voltage are pushed into a FIFO buffer which acts as a moving-average window. Longer window = smoother signal, but longer time delay
 * Contents of the window are dynamically divided into 'low' and 'high' groups before being averaged, hence accounting for background IR radiation
 * The subtraction of the 'high' average from the 'low' average produces the output of the detector.
 * 
 * This exploits the 600Hz on-off switching of the beacon, but in principle is valid for any switching frequency.
 * It is essential, however, that the sampling frequency _not_ be an exact divisor of 600Hz, e.g. 200Hz
 * Ideally it would have a prime mathematical relationship with the beacon frequency, but as long as it avoids being an exact divisor or close to one, it should be fine.
 * (I'm not exactly an expert on this, but this is my basic understanding)
 * 
 * Currently there is no explicit timing in the loop, and it runs at approximately 457Hz for a baudrate of 250000 and a window length of 256 samples, sending only the detector output over serial.
 * Clearly, some explicit timing will need to be implemented to make the behaviour predictable.
 * 
 * Author: Mike Angus
*/

#define INDICATOR 9
#define IR_MEASURE_PIN 7

//Window size _must_ be a power of two: 2,4,8,16,32,64,128,256 etc
#define IR_WINDOW_SIZE 256
#define IR_WINDOW_WRAPPING_BITMASK (IR_WINDOW_SIZE - 1)

//Fast FIFO buffer
typedef struct FIFO
{
	int buf[IR_WINDOW_SIZE];
	unsigned int index;
}FIFO;

//Function prototypes
void fifoWrite(FIFO* fifo, int value, int wrappingBitmask);
int fifoReadOffset(FIFO* fifo, int indexOffset, int wrappingBitmask);
int getBeaconLevel(FIFO* samplingWindow, int windowSize, int wrappingBitmask);

//FIFO buffer for IR beacon windowing
FIFO irWindow;


bool endFlag = 0; //for indicator LED test

//Setup function
void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(INDICATOR, OUTPUT);
  Serial.begin(250000);
  Serial.println("Sensor Organ Reporting");

}

//Main loop
void loop() {

  //Fade in the indicator LED
  while(!endFlag) {
    for(int pwmVal = 0; pwmVal <256; pwmVal++) {
      analogWrite(INDICATOR, pwmVal);
      delay(10);
    }
    endFlag = true;
  }

	//Read IR measurement and add to the FIFO buffer that is the measurement window
	fifoWrite(&irWindow, analogRead(IR_MEASURE_PIN), IR_WINDOW_WRAPPING_BITMASK);
	
	//Extract the measured beacon level
	int reading = getBeaconLevel(&irWindow, IR_WINDOW_SIZE, IR_WINDOW_WRAPPING_BITMASK);

//	Serial.print("Beacon Level Reading: ");
	Serial.println(reading);

// //Test code for reading raw IR value
// int reading = analogRead(IR_MEASURE_PIN);
// Serial.print("IR Reading: ");
// Serial.println(reading);

// //LED Flashing Routine
//  digitalWrite(INDICATOR, HIGH);   // turn the LED on (HIGH is the voltage level)
//  Serial.println("FLASH ON");
//  delay(1000);                       // wait for a second
//  digitalWrite(INDICATOR, LOW);    // turn the LED off by making the voltage LOW
//  Serial.println("FLASH OFF");
//  delay(1000);                       // wait for a second
}

/*
* GETBEACONLEVEL
* - Divides the samples in the sampling window into two groups, low and high
* - Each group is averaged to filter out noise and give a more reliable low and high value
* - The difference between these two averages, high - low, is then the measured beacon level
* - This should still work under different levels of background IR radiation, just the numbers will be different
*/
int getBeaconLevel(FIFO* samplingWindow, int windowSize, int wrappingBitmask) {

	//Find min and max values
	int max = 0;
	int min = 1023;
	int currentSample;

	for (int i=0; i<windowSize; ++i) {
		//Read next sample from the window
		currentSample = fifoReadOffset(samplingWindow, i, wrappingBitmask);

		//Update max or min value if new one found
		if (currentSample > max) {
			max = currentSample;
		}
		if (currentSample < min) {
			min = currentSample;
		}
	}

	//Calculate two averages, one for low, one for high
	//Achieved by keeping a running total rather than two actual data structures for the groups
	long lowTotal = 0; 
	long highTotal = 0;
	int numLows = 0;
	int numHighs = 0;
	for (int i=0; i<windowSize; ++i) {
		//Read next sample from the window
		currentSample = fifoReadOffset(samplingWindow, i, wrappingBitmask);

		//Add to lows group if closer to min than to max, otherwise add to highs group
		if((currentSample - min) < (max - currentSample)) {
			lowTotal += currentSample;
			numLows++;
		} else {
			highTotal += currentSample;
			numHighs++;
		}
	}

	//Calculate the averaged low value and the averaged high value
	//Note this is integer division so the fractional part will be discarded
	int averageLow = lowTotal/numLows;
	int averageHigh = highTotal/numHighs;

  //DEBUG:
//  Serial.println();
////  Serial.println("Window contents:");
////  for(int i=0; i<windowSize; ++i) {
////    Serial.println(fifoReadOffset(samplingWindow, i, wrappingBitmask));
////  }
//  Serial.println("LowTotal    NumLows    HighTotal    NumHighs    AverageLow    AverageHigh");
//  Serial.print(lowTotal);
//  Serial.print("        ");
//  Serial.print(numLows);
//  Serial.print("            ");
//  Serial.print(highTotal);
//  Serial.print("          ");
//  Serial.print(numHighs);
//  Serial.print("        ");
//  Serial.print(averageLow);
//  Serial.print("           ");
//  Serial.println(averageHigh);

	//Return the difference; this is the beacon level reading
	return averageHigh - averageLow;
}

//FIFO functions

/*********************************************************************************
FIFOWRITE
-Fast function for FIFO buffering
-Writes the given value into the next buffer location
-Based on code from https://stackoverflow.com/questions/9718116/improving-c-circular-buffer-efficiency
-Buffer size must be a power of two for the bitmasking method of index wrapping to work
***********************************************************************************/
void fifoWrite(FIFO* fifo, int value, int wrappingBitmask)
{
	fifo->buf[(fifo->index++) & wrappingBitmask] = value;
}

/*********************************************************************************
FIFOREADOFFSET
-Fast function for reading out of either end of a FIFO buffer
-Reads at an offset from the last value written
-An indexOffset of -1 will return the last value written, -2 the value before that, etc...
-An indexOffset of 0 will return the oldest value, +1 the next oldest, etc...
***********************************************************************************/
int fifoReadOffset(FIFO* fifo, int indexOffset, int wrappingBitmask)
{
	return (fifo->buf[(fifo->index + indexOffset) & wrappingBitmask]);
}
