#ifndef ARE_MORPHOLOGY_HPP
#define ARE_MORPHOLOGY_HPP

#include <PolyVox/Mesh.h>
#include "ARE/Logging.h"
#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/morphology_descriptors.hpp"
#include "simulatedER/Blueprint.h"
#include "simulatedER/skeleton_generation.hpp"
#include "simulatedER/nn2/NN2CPPNGenome.hpp"
#include "simulatedER/nn2/sq_cppn_genome.hpp"


namespace are {

namespace  sim {

/**
 * @brief Base class to create a ARE robot
 */
class AREMorphology: public Morphology{
public:
    AREMorphology(const settings::ParametersMapPtr &param) : Morphology(param){}
    AREMorphology(const AREMorphology& arem): Morphology(arem),
        id(arem.id),
        organ_list(arem.organ_list),
        numSkeletonVoxels(arem.numSkeletonVoxels),
        skeletonHandles(arem.skeletonHandles),
        skeletonListVertices(arem.skeletonListVertices),
        skeletonListIndices(arem.skeletonListIndices),
        feat_desc(arem.feat_desc),
        organ_mat_desc(arem.organ_mat_desc),
        matrix_desc(arem.matrix_desc),
        blueprint(arem.blueprint)
    {}


    void createAtPosition(float,float,float) override;

    void setPosition(float,float,float);
    void load(const std::string &filepath);
    bool convex_decomposition(int meshHandle, int numSkeletonVoxels, std::vector<int> &skeletonHandles);
    bool generate_skeleton_mesh(const skeleton::type &skeleton_matrix,int &mesh_handle);
    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper(std::vector<int> &gripperHandles);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper(const std::vector<int> &gripperHandles);
    /**
     * @brief Removes all physical connector created with createTemporalConnector
     */
    void destroy_physical_connectors();
    /**
     * @brief This method tests that robot as a whole.
     */
    void testRobot();
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum, const std::string &folder = Logging::log_folder);

    void set_load_mode(){is_load_mode = true;}
    void set_decode_mode(){is_load_mode = false;}

    //Setters and Getters
    const OrganMatrixDesc &getOrganPosDesc() const {return organ_mat_desc;}
    const MatrixDesc &getMatrixDesc() const {return matrix_desc;}
    const FeaturesDesc &getFeatureDesc() const {return feat_desc;}
    int get_wheel_number() const {return feat_desc.wheel_number;}
    int get_joint_number() const {return feat_desc.joint_number;}
    int get_sensor_number() const {return feat_desc.sensor_number;}
    std::vector<int> getOrganTypes(){return blueprint.getOrganTypes();}
    std::vector<std::vector<float>> getOrganPosList(){return blueprint.getOrganPosList();}
    std::vector<std::vector<float>> getOrganOriList(){return blueprint.getOrganOriList();}
    const std::vector<float> &getSkeletonListVertices() const {return skeletonListVertices;}
    const std::vector<int> &getSkeletonListIndices() const {return skeletonListIndices;}
protected:
    std::vector<std::vector<int>> list_of_voxels;

    unsigned int id = 0;
    // Variables used to contain handles.
    std::vector<Organ> organ_list;

    //skeleton information
    int numSkeletonVoxels;
    std::vector<int> skeletonHandles;
    std::vector<float> skeletonListVertices;
    std::vector<int> skeletonListIndices;
    std::vector<std::vector<std::vector<int>>> skeletonSurfaceCoord;

    //Morphological Descriptor
    FeaturesDesc feat_desc;
    OrganMatrixDesc organ_mat_desc;
    MatrixDesc matrix_desc;

    Blueprint blueprint;
    bool is_load_mode = false;
};

class ManuallyDesignedMorphology: public AREMorphology{
public:
    ManuallyDesignedMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    ManuallyDesignedMorphology(const AREMorphology& arem): AREMorphology(arem)
    {}

    void create() override;
    void generate(skeleton::type &skeleton_matrix, std::vector<Organ> &organs_list, const std::vector<std::vector<int>> &list_of_voxels);
};

class CPPNMorphology: public AREMorphology{
public:
    void create() override;
    void generate(skeleton::type &skeletonMatrix, skeleton::coord_t &skeleton_surface);
    void generate_growing(skeleton::type &skeletonMatrix, skeleton::coord_t &skeleton_surface);

    void set_cppn(const nn2_cppn_t &nn){cppn = nn;}
    const nn2_cppn_t &get_cppn(){return cppn;}
private:
    nn2_cppn_t cppn;
};

class SQCPPNMorphology: public AREMorphology{

};

}//sim

}//are
#endif //ARE_MORPHOLOGY_HPP
