#ifndef ARE_MORPHOLOGY_HPP
#define ARE_MORPHOLOGY_HPP

#include <PolyVox/Mesh.h>
#include "ARE/Logging.h"
#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/morphology_descriptors.hpp"
#include "simulatedER/morphology_constants.hpp"
#include "simulatedER/Blueprint.h"
#include "simulatedER/skeleton_generation.hpp"
#include "simulatedER/morph_genomes.hpp"
#include "simulatedER/sq_genome.hpp"


namespace are {

namespace  sim {

struct ManufacturabilityResult{
    bool noCollisions;
    bool noBadOrientations;
    bool isGripperAccess;
    // Constructor
    ManufacturabilityResult(){
        noCollisions = true;
        noBadOrientations = true;
        isGripperAccess = true;
    }
    std::vector<bool> get_results() const{
        std::vector<bool> resVector;
        resVector.push_back(noCollisions);
        resVector.push_back(noBadOrientations);
        resVector.push_back(isGripperAccess);
        return resVector;
    }
};

typedef ManufacturabilityResult ManRes;
/**
 * @brief Base class to create a ARE robot
 */
class AREMorphology: public Morphology{
public:
    typedef std::shared_ptr<AREMorphology> Ptr;
    typedef std::shared_ptr<const AREMorphology> ConstPtr;

    AREMorphology(const settings::ParametersMapPtr &param) : Morphology(param){}
    AREMorphology(const AREMorphology& arem): Morphology(arem),
        id(arem.id),
        organ_list(arem.organ_list),
        numSkeletonVoxels(arem.numSkeletonVoxels),
        skeletonHandles(arem.skeletonHandles),
        skeletonListVertices(arem.skeletonListVertices),
        skeletonListIndices(arem.skeletonListIndices),
        feat_desc(arem.feat_desc),
        organ_mat_desc(arem.organ_mat_desc),
        matrix_desc(arem.matrix_desc),
        blueprint(arem.blueprint),
        man_test_res(arem.man_test_res)
    {}


    void createAtPosition(float,float,float) override;

    void setPosition(float,float,float);
    void load(const std::string &filepath);
    bool convex_decomposition(int meshHandle, int numSkeletonVoxels, std::vector<int> &skeletonHandles);
    bool generate_skeleton_mesh(skeleton::type &skeleton_matrix, int &mesh_handle);
    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper(std::vector<int> &gripperHandles);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper(const std::vector<int> &gripperHandles);
    /**
     * @brief Removes all physical connector created with createTemporalConnector
     */
    void destroy_physical_connectors();
    /**
     * @brief This method tests that robot as a whole.
     */
    void test_robot();
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum, const std::string &folder = Logging::log_folder);


    void set_load_mode(){is_load_mode = true;}
    void set_decode_mode(){is_load_mode = false;}

    //Setters and Getters
    const OrganMatrixDesc &getOrganPosDesc() const {return organ_mat_desc;}
    const MatrixDesc &getMatrixDesc() const {return matrix_desc;}
    const FeaturesDesc &getFeatureDesc() const {return feat_desc;}
    int get_wheel_number() const {return feat_desc.wheel_number;}
    int get_joint_number() const {return feat_desc.joint_number;}
    int get_sensor_number() const {return feat_desc.sensor_number;}
    std::vector<int> getOrganTypes(){return blueprint.getOrganTypes();}
    std::vector<std::vector<float>> getOrganPosList(){return blueprint.getOrganPosList();}
    std::vector<std::vector<float>> getOrganOriList(){return blueprint.getOrganOriList();}
    const std::vector<float> &getSkeletonListVertices() const {return skeletonListVertices;}
    const std::vector<int> &getSkeletonListIndices() const {return skeletonListIndices;}

    const ManRes &get_man_test_res(){return man_test_res;}
    void set_man_test_res(const ManRes& mtr){man_test_res = mtr;}

protected:
    /**
     * @brief check_repress_organs_biased check the components which are not colliding with others or with the skeleton. They will be removed until having only 8 left. There is a bias toward keeping low components
     * @param skeleton_matrix
     * @param gripper_handles
     */
    virtual void check_repress_organs_biased(const skeleton::type &skeleton_matrix, const std::vector<int> &gripper_handles);
    /**
     * @brief check_repress_organs_nobias check the components which are not colliding with others or with the skeleton. They will be removed until having only 8 left
     * @param skeleton_matrix
     * @param gripper_handles
     */
    virtual void check_repress_organs_nobias(const skeleton::type &skeleton_matrix, const std::vector<int> &gripper_handles);

    void create_organ_list(const organ::organ_list_t &organ_i_list);

    std::vector<std::vector<int>> list_of_voxels;

    unsigned int id = 0;
    // Variables used to contain handles.
    std::vector<Organ> organ_list;

    //skeleton information
    int numSkeletonVoxels;
    std::vector<int> skeletonHandles;
    std::vector<float> skeletonListVertices;
    std::vector<int> skeletonListIndices;
    std::vector<std::vector<std::vector<int>>> skeletonSurfaceCoord;

    //Morphological Descriptor
    FeaturesDesc feat_desc;
    OrganMatrixDesc organ_mat_desc;
    MatrixDesc matrix_desc;

    Blueprint blueprint;
    bool is_load_mode = false;

    ManRes man_test_res;
};

class ManuallyDesignedMorphology: public AREMorphology{
public:
    typedef std::shared_ptr<ManuallyDesignedMorphology> Ptr;
    typedef std::shared_ptr<const ManuallyDesignedMorphology> ConstPtr;

    ManuallyDesignedMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    ManuallyDesignedMorphology(const ManuallyDesignedMorphology& arem): AREMorphology(arem)
    {}

    are::Morphology::Ptr clone() const override
    {return std::make_shared<ManuallyDesignedMorphology>(*this);}

    void create() override;
    void generate(skeleton::type &skeleton_matrix, std::vector<Organ> &organs_list, const std::vector<std::vector<int>> &list_of_voxels);
};

class CPPNMorphology: public AREMorphology{
public:
    typedef std::shared_ptr<CPPNMorphology> Ptr;
    typedef std::shared_ptr<const CPPNMorphology> ConstPtr;

    CPPNMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    CPPNMorphology(const CPPNMorphology& arem): AREMorphology(arem), cppn(arem.cppn)
    {}


    are::Morphology::Ptr clone() const override
    {return std::make_shared<CPPNMorphology>(*this);}

    void create() override;

    void set_cppn(const nn2_cppn_t &nn){cppn = nn;}
    const nn2_cppn_t &get_cppn(){return cppn;}
private:

    nn2_cppn_t cppn;
};

class SQCPPNMorphology: public AREMorphology{
public:
    using cppn_t = sq_cppn::cppn_t;

    typedef std::shared_ptr<SQCPPNMorphology> Ptr;
    typedef std::shared_ptr<const SQCPPNMorphology> ConstPtr;

    SQCPPNMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    SQCPPNMorphology(const SQCPPNMorphology& arem):
        AREMorphology(arem), cppn(arem.cppn), quadric(arem.quadric)
    {}

    are::Morphology::Ptr clone() const override
    {return std::make_shared<SQCPPNMorphology>(*this);}

    void create() override;

    void set_cppn(const cppn_t &nn){cppn = nn;}
    const cppn_t &get_cppn(){return cppn;}

    void set_quadric(const sq_t& sq){quadric = sq;}
    const sq_t &get_quadric(){return quadric;}


private:
    void create_organs();
    cppn_t cppn;
    sq_t quadric;
};

class SQMorphology: public AREMorphology{
public:
    typedef std::shared_ptr<SQMorphology> Ptr;
    typedef std::shared_ptr<const SQMorphology> ConstPtr;

    SQMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    SQMorphology(const SQMorphology& arem):
        AREMorphology(arem), comp_gen(arem.comp_gen), quadric(arem.quadric)
    {}

    are::Morphology::Ptr clone() const override
    {return std::make_shared<SQMorphology>(*this);}

    void create() override;


    void set_comp_gen(const cg_t &nn){comp_gen = nn;}
    const cg_t &get_comp_gen(){return comp_gen;}

    void set_quadric(const sq_t& sq){quadric = sq;}
    const sq_t &get_quadric(){return quadric;}

private:
    void create_organs();

    /**
     * @brief check_repress_organs_nobias Specific implementation for this encoding
     * @param skeleton_matrix
     * @param gripper_handles
     */
    void check_repress_organs_nobias(const skeleton::type &skeleton_matrix,
                              const std::vector<int> &gripper_handles) override;


    std::vector<int> repressed_comp_genes;
    cg_t comp_gen;
    sq_t quadric;
};

}//sim

}//are
#endif //ARE_MORPHOLOGY_HPP
