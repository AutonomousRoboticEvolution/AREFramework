#ifndef ARE_MORPHOLOGY_HPP
#define ARE_MORPHOLOGY_HPP

#include <PolyVox/Mesh.h>
#include "ARE/Logging.h"
#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/morphology_descriptors.hpp"
#include "simulatedER/morphology_constants.hpp"
#include "simulatedER/Blueprint.h"
#include "simulatedER/skeleton_generation.hpp"
#include "simulatedER/nn2/NN2CPPNGenome.hpp"
#include "simulatedER/nn2/sq_cppn_genome.hpp"
#include "simulatedER/nn2/sq_genome.hpp"


namespace are {

namespace  sim {

struct ManufacturabilityResult{
    bool noCollisions;
    bool noBadOrientations;
    bool isGripperAccess;
    // Constructor
    ManufacturabilityResult(){
        noCollisions = true;
        noBadOrientations = true;
        isGripperAccess = true;
    }
    std::vector<bool> get_results() const{
        std::vector<bool> resVector;
        resVector.push_back(noCollisions);
        resVector.push_back(noBadOrientations);
        resVector.push_back(isGripperAccess);
        return resVector;
    }
};

typedef ManufacturabilityResult ManRes;
/**
 * @brief Base class to create a ARE robot
 */
class AREMorphology: public Morphology{
public:
    typedef std::shared_ptr<AREMorphology> Ptr;
    typedef std::shared_ptr<const AREMorphology> ConstPtr;

    AREMorphology(const settings::ParametersMapPtr &param) : Morphology(param){}
    AREMorphology(const AREMorphology& arem): Morphology(arem),
        id(arem.id),
        organ_list(arem.organ_list),
        numSkeletonVoxels(arem.numSkeletonVoxels),
        skeletonHandles(arem.skeletonHandles),
        skeletonListVertices(arem.skeletonListVertices),
        skeletonListIndices(arem.skeletonListIndices),
        feat_desc(arem.feat_desc),
        organ_mat_desc(arem.organ_mat_desc),
        matrix_desc(arem.matrix_desc),
        blueprint(arem.blueprint),
        man_test_res(arem.man_test_res)
    {}


    void createAtPosition(float,float,float) override;

    void setPosition(float,float,float);
    void load(const std::string &filepath);
    bool convex_decomposition(int meshHandle, int numSkeletonVoxels, std::vector<int> &skeletonHandles);
    bool generate_skeleton_mesh(skeleton::type &skeleton_matrix, int &mesh_handle);
    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper(std::vector<int> &gripperHandles);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper(const std::vector<int> &gripperHandles);
    /**
     * @brief Removes all physical connector created with createTemporalConnector
     */
    void destroy_physical_connectors();
    /**
     * @brief This method tests that robot as a whole.
     */
    void test_robot();
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum, const std::string &folder = Logging::log_folder);


    void set_load_mode(){is_load_mode = true;}
    void set_decode_mode(){is_load_mode = false;}

    //Setters and Getters
    const OrganMatrixDesc &getOrganPosDesc() const {return organ_mat_desc;}
    const MatrixDesc &getMatrixDesc() const {return matrix_desc;}
    const FeaturesDesc &getFeatureDesc() const {return feat_desc;}
    int get_wheel_number() const {return feat_desc.wheel_number;}
    int get_joint_number() const {return feat_desc.joint_number;}
    int get_sensor_number() const {return feat_desc.sensor_number;}
    std::vector<int> getOrganTypes(){return blueprint.getOrganTypes();}
    std::vector<std::vector<float>> getOrganPosList(){return blueprint.getOrganPosList();}
    std::vector<std::vector<float>> getOrganOriList(){return blueprint.getOrganOriList();}
    const std::vector<float> &getSkeletonListVertices() const {return skeletonListVertices;}
    const std::vector<int> &getSkeletonListIndices() const {return skeletonListIndices;}

    const ManRes &get_man_test_res(){return man_test_res;}
    void set_man_test_res(const ManRes& mtr){man_test_res = mtr;}

protected:
    virtual void check_repress_organs(const skeleton::type &skeleton_matrix, const std::vector<int> &gripper_handles);

    void create_organ_list(const organ::organ_list_t &organ_i_list);

    std::vector<std::vector<int>> list_of_voxels;

    unsigned int id = 0;
    // Variables used to contain handles.
    std::vector<Organ> organ_list;

    //skeleton information
    int numSkeletonVoxels;
    std::vector<int> skeletonHandles;
    std::vector<float> skeletonListVertices;
    std::vector<int> skeletonListIndices;
    std::vector<std::vector<std::vector<int>>> skeletonSurfaceCoord;

    //Morphological Descriptor
    FeaturesDesc feat_desc;
    OrganMatrixDesc organ_mat_desc;
    MatrixDesc matrix_desc;

    Blueprint blueprint;
    bool is_load_mode = false;

    ManRes man_test_res;
};

class ManuallyDesignedMorphology: public AREMorphology{
public:
    typedef std::shared_ptr<ManuallyDesignedMorphology> Ptr;
    typedef std::shared_ptr<const ManuallyDesignedMorphology> ConstPtr;

    ManuallyDesignedMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    ManuallyDesignedMorphology(const ManuallyDesignedMorphology& arem): AREMorphology(arem)
    {}

    are::Morphology::Ptr clone() const override
    {return std::make_shared<ManuallyDesignedMorphology>(*this);}

    void create() override;
    void generate(skeleton::type &skeleton_matrix, std::vector<Organ> &organs_list, const std::vector<std::vector<int>> &list_of_voxels);
};

class CPPNMorphology: public AREMorphology{
public:
    typedef std::shared_ptr<CPPNMorphology> Ptr;
    typedef std::shared_ptr<const CPPNMorphology> ConstPtr;

    CPPNMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    CPPNMorphology(const CPPNMorphology& arem): AREMorphology(arem), cppn(arem.cppn)
    {}


    are::Morphology::Ptr clone() const override
    {return std::make_shared<CPPNMorphology>(*this);}

    void create() override;

    void set_cppn(const nn2_cppn_t &nn){cppn = nn;}
    const nn2_cppn_t &get_cppn(){return cppn;}
private:

    nn2_cppn_t cppn;
};

class SQCPPNMorphology: public AREMorphology{
public:
    using sq_t = quadric_t<quadric_params>;
    using cppn_t = sq_cppn::cppn_t;

    typedef std::shared_ptr<SQCPPNMorphology> Ptr;
    typedef std::shared_ptr<const SQCPPNMorphology> ConstPtr;

    SQCPPNMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    SQCPPNMorphology(const SQCPPNMorphology& arem):
        AREMorphology(arem), cppn(arem.cppn), quadric(arem.quadric)
    {}

    are::Morphology::Ptr clone() const override
    {return std::make_shared<SQCPPNMorphology>(*this);}

    void create() override;

    void set_cppn(const cppn_t &nn){cppn = nn;}
    const cppn_t &get_cppn(){return cppn;}

    void set_quadric(const sq_t& sq){quadric = sq;}
    const sq_t &get_quadric(){return quadric;}

    int get_nbr_organs(){return nbr_organs;}
    void set_nbr_organs(int no){nbr_organs = no;}

private:
    void create_organs();

    cppn_t cppn;
    sq_t quadric;
    int nbr_organs;

};

template<typename cg_param_t, typename sq_param_t>
class SQMorphology: public AREMorphology{
public:
    using cg_t = ComponentsGenome<cg_param_t>;
    using sq_t = quadric_t<sq_param_t>;

    typedef std::shared_ptr<SQMorphology> Ptr;
    typedef std::shared_ptr<const SQMorphology> ConstPtr;

    SQMorphology(const settings::ParametersMapPtr &param) : AREMorphology(param){}
    SQMorphology(const SQMorphology& arem):
        AREMorphology(arem), comp_gen(arem.comp_gen), quadric(arem.quadric)
    {}

    are::Morphology::Ptr clone() const override
    {return std::make_shared<SQMorphology>(*this);}

    void create() override
    {
        int meshHandle = -1;
        mainHandle = -1;
        bool convexDecompositionSuccess = false;
        std::vector<int> gripperHandles;
        createGripper(gripperHandles);
        numSkeletonVoxels = 0;
        createHead();
        skeleton::type skeleton_matrix(PolyVox::Region(PolyVox::Vector3DInt32(-morph_const::matrix_size/2, -morph_const::matrix_size/2, -morph_const::matrix_size/2),
                                                    PolyVox::Vector3DInt32(morph_const::matrix_size/2, morph_const::matrix_size/2, morph_const::matrix_size/2)));
        organ::organ_list_t organ_i_list;
        sq_decoder::decode<sq_t,cg_t>(quadric,comp_gen,nbr_organs,skeleton_matrix,organ_i_list,numSkeletonVoxels);
        create_organ_list(organ_i_list);

        // Create mesh for skeleton
        bool indVerResult = generate_skeleton_mesh(skeleton_matrix,meshHandle);
        if(indVerResult)
            convexDecompositionSuccess = convex_decomposition(meshHandle,numSkeletonVoxels,skeletonHandles);
        if(!convexDecompositionSuccess){
            // Stop generating body plan if convex decomposition fails
            std::cerr << "Not generating robot because convex decomposition failed. Stopping simulation." << std::endl;
            return;
        }

        if(convexDecompositionSuccess){
            check_repress_organs(skeleton_matrix,gripperHandles);
            //create_organs();
        }
        else{
            // Stop generating body plan if convex decomposition fails
            std::cerr << "Not generating robot because convex decomposition failed. Stopping simulation." << std::endl;
            return;
        }

        //Create morphological descriptors
        if(indVerResult || convexDecompositionSuccess){
            feat_desc.create(skeleton_matrix,organ_list);
            matrix_desc.create(skeleton_matrix,organ_list);
            organ_mat_desc.create(skeleton_matrix,organ_list); //todo remove this one or put an option for either matrix or organ_mat
        }

        //create blueprint
        if(settings::getParameter<settings::Boolean>(parameters,"#saveBlueprint").value)
            blueprint.createBlueprint(organ_list);
        destroyGripper(gripperHandles);
        destroy_physical_connectors();
        // Export model
        if(settings::getParameter<settings::Boolean>(parameters,"#isExportModel").value){
            std::string model_folder = settings::getParameter<settings::String>(parameters,"#modelRepository").value;
            if(model_folder.empty() || model_folder == "None")
                exportRobotModel(morph_id);
            else
                exportRobotModel(morph_id,model_folder);
        }

        retrieveOrganHandles(mainHandle,proxHandles,IRHandles,wheelHandles,jointHandles,camera_handle);
        // EB: This flag tells the simulator that the shape is convex even though it might not be. Be careful,
        // this might mess up with the physics engine if the shape is non-convex!
        // I set this flag to prevent the warning showing and stopping evolution.
        simSetObjectInt32Parameter(mainHandle, sim_shapeintparam_convex, 1);
    }

    void set_comp_gen(const cg_t &nn){comp_gen = nn;}
    const cg_t &get_comp_gen(){return comp_gen;}

    void set_quadric(const sq_t& sq){quadric = sq;}
    const sq_t &get_quadric(){return quadric;}

    int get_nbr_organs(){return nbr_organs;}
    void set_nbr_organs(int no){nbr_organs = no;}

private:
    void create_organs(){
            for(Organ &organ: organ_list)
        organ.createOrgan(mainHandle);
    }
    void check_repress_organs(const skeleton::type &skeleton_matrix, const std::vector<int> &gripper_handles) override
    {
        std::vector<int> bad_organs_idxs;
        bool no_bad_organs = false;
        create_organs();
        while(!no_bad_organs){
            //STEP 1: Check organs which are colliding with others or with the skeleton
            for(int i = 0; i < organ_list.size(); i++){
                //TODO joints number limit
                Organ &organ = organ_list[i];
                // organ.createOrgan(mainHandle);
                if(organ.getOrganType() != 0)
                    organ.testOrgan(skeleton_matrix, -1, skeletonHandles, organ_list);
                if(organ.organColliding || organ.organInsideSkeleton)
                    bad_organs_idxs.push_back(i);
            }
            //STEP 2: Randomly pick one and repress it
            if(!bad_organs_idxs.empty()){
                int rand_idx = randomNum->randInt(0,bad_organs_idxs.size()-1);
                comp_gen.remove(bad_organs_idxs[rand_idx]-1);
                organ_list[bad_organs_idxs[rand_idx]].repressOrgan();
                organ_list.erase(organ_list.begin() + bad_organs_idxs[rand_idx]);
            }else no_bad_organs = true;
            for(Organ &organ: organ_list){
                organ.organColliding = false;
                organ.organInsideSkeleton = false;
            }

            bad_organs_idxs.clear();
        }
    }


    std::vector<int> repressed_comp_genes;
    cg_t comp_gen;
    sq_t quadric;
    int nbr_organs;

};

}//sim

}//are
#endif //ARE_MORPHOLOGY_HPP
