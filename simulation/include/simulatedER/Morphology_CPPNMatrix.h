#ifndef Morphology_CPPNMatrix_H
#define Morphology_CPPNMatrix_H

#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/GenomeDecoder.h"
#include "ARE/Logging.h"

#include "PolyVox/RawVolume.h"
#include "PolyVox/MarchingCubesSurfaceExtractor.h"
#include "eigen3/Eigen/Core"

#include "math.h"

namespace are {

namespace sim {

class Morphology_CPPNMatrix : public Morphology
{
public:
    Morphology_CPPNMatrix(const settings::ParametersMapPtr &param) : Morphology(param){}

    class RobotManRes{
    public:
        bool noCollisions;
        bool noBadOrientations;
        bool isGripperAccess;
        // Constructor
        RobotManRes(){
            noCollisions = true;
            noBadOrientations = true;
            isGripperAccess = true;
        }
        std::vector<bool> getResVector(){
            std::vector<bool> resVector;
            resVector.push_back(noCollisions);
            resVector.push_back(noBadOrientations);
            resVector.push_back(isGripperAccess);
            return resVector;
        }
    };
    RobotManRes robotManRes;

    are::Morphology::Ptr clone() const override
        {return std::make_shared<Morphology_CPPNMatrix>(*this);}

    void create() override;
    void createAtPosition(float,float,float) override;
    void setPosition(float,float,float);

    /////////////////////////////
    ///// Create morphology /////
    /////////////////////////////
    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh, std::vector<float>& vertices, std::vector<int>& indices);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper();

    /**
     * @brief Takes the last three outputs of the network and converts them into rotations (radians) in x, y and z.
     * \todo EB: This method needs updating. Only one output required.
     */
    void setOrganOrientation(NEAT::NeuralNetwork &cppn, Organ& organ);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper();

    ////////////////////////////////////////////
    /////  Manufacturability testing stuff /////
    ////////////////////////////////////////////
    /// \todo EB: Might be good idea to move this testing to a class
    /**
     * @brief This method tests that robot as a whole.
     */
    void testRobot(PolyVox::RawVolume<uint8_t>& skeletonMatrix);

    ///////////////////////////
    ///// Surface methods /////
    ///////////////////////////
    /**
     * @brief This method generates organs only in specific regions of the surface of the skeleton according to the cppn.
     */
    void generateOrgans(NEAT::NeuralNetwork &cppn, std::vector<std::vector<std::vector<int>>> &skeletonSurfaceCoord);
    /**
     * @brief This method generates the orientation of the organ accoriding to the "normal" of the surface
     * In reality, it takes the position of the last outer voxel. In other words, it generates orientations in
     * intervals of 45o.
     */
    void generateOrientations(int x, int y, int z, std::vector<float> &orientation);

    //////////////////////////////////
    ///// Miscellanous functions /////
    //////////////////////////////////
    /**
     * @brief Export mesh file (stl) from a list of vertices and indices.
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportMesh(int loadInd, std::vector<float> vertices, std::vector<int> indices);
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum);

    ///////////////////////////////
    ///// Setters and getters /////
    ///////////////////////////////
    std::vector<bool> getRobotManRes(){return robotManRes.getResVector();};
    NEAT::NeuralNetwork getGenome(){return nn;};
    void setGenome(NEAT::NeuralNetwork genome){nn = genome;};

    /// Getters for descriptors.
    Eigen::VectorXd getMorphDesc(){return indDesc.cartDesc.cartDesc;};
    int get_wheelNumber(){return indDesc.cartDesc.wheelNumber;}
    int get_jointNumber(){return indDesc.cartDesc.jointNumber;}
    int get_sensorNumber(){return indDesc.cartDesc.sensorNumber;}

private:
    ///////////////////////
    ///// Descriptors /////
    ///////////////////////

    class CartDesc
    {
    public:
        //const int ORGANTRAITLIMIT = 5;
        const int ORGANTRAITLIMIT = 16;
        //const float DIMENSIONLIMIT = 0.23;
        const float DIMENSIONLIMIT = 0.55; // Skeleton - > 0.23m; Joint - > 0.08; 1 Skeleton + 4 Joints
        float robotWidth; // X
        float robotDepth; // Y
        float robotHeight; // Z
        int voxelNumber;
        int wheelNumber;
        int sensorNumber;
        int casterNumber;
        int jointNumber;
        Eigen::VectorXd cartDesc;
        // Constructor
        CartDesc(){
            cartDesc.resize(8);
            robotWidth = 0;
            robotDepth = 0;
            robotHeight = 0;
            voxelNumber = 0;
            wheelNumber = 0;
            sensorNumber = 0;
            casterNumber = 0;
            jointNumber = 0;
            setCartDesc();
        }
        void setCartDesc(){
            cartDesc(0) = robotWidth / DIMENSIONLIMIT;
            cartDesc(1) = robotDepth / DIMENSIONLIMIT;
            cartDesc(2) = robotHeight / DIMENSIONLIMIT;
            cartDesc(3) = (double) voxelNumber / VOXELS_NUMBER;
            cartDesc(4) = (double) wheelNumber / ORGANTRAITLIMIT;
            cartDesc(5) = (double) sensorNumber / ORGANTRAITLIMIT;
            cartDesc(6) = (double) jointNumber / ORGANTRAITLIMIT;
            cartDesc(7) = (double) casterNumber / ORGANTRAITLIMIT;
        }
        void countOrgans(std::vector<Organ> organList){
            for(std::vector<Organ>::iterator it = organList.begin(); it != organList.end(); it++){
                if(!it->isOrganRemoved() && it->isOrganChecked()) {
                    if (it->getOrganType() == 1)
                        wheelNumber++;
                    if (it->getOrganType() == 2)
                        sensorNumber++;
                    if (it->getOrganType() == 3)
                        jointNumber++;
                    if (it->getOrganType() == 4)
                        casterNumber++;
                }

            }
        }
        void getRobotDimmensions(std::vector<Organ> organList){
            float minX = 0, minY = 0, minZ = 0, maxX = 0, maxY = 0, maxZ = 0;
            for(auto & i : organList) {
                if (!i.isOrganRemoved() && i.isOrganChecked()) {
                    if(i.connectorPos.at(0) > maxX)
                        maxX = i.connectorPos.at(0);
                    if(i.connectorPos.at(1) > maxY)
                        maxY = i.connectorPos.at(1);
                    if(i.connectorPos.at(2) > maxZ)
                        maxZ = i.connectorPos.at(2);
                    if(i.connectorPos.at(0) < minX)
                        minX = i.connectorPos.at(0);
                    if(i.connectorPos.at(1) < minY)
                        minY = i.connectorPos.at(1);
                    if(i.connectorPos.at(2) < minZ)
                        minZ = i.connectorPos.at(2);
                }
            }
            // Get dimmensions
            robotWidth = abs(maxX - minX);
            robotDepth = abs(maxY - minY);
            robotHeight = abs(maxZ - minZ);
        }
    };

    class Descriptors{
    public:
        CartDesc cartDesc;
    };



private:
    NEAT::NeuralNetwork nn;

    /////////////////////
    /////////////////////
    constexpr static const float VOXEL_SIZE = 0.0009; //m続 - 0.9mm続
    // WAS 4 -> 3.6mm
    // 6 -> 5.4mm
    // 11 -> 9.9mm (EB: with this value there is no stack overflow!)
    static const int VOXEL_MULTIPLIER = 22;
    constexpr static const float VOXEL_REAL_SIZE = VOXEL_SIZE * static_cast<float>(VOXEL_MULTIPLIER);
    static const int MATRIX_SIZE = (264 / VOXEL_MULTIPLIER);
    static const int MATRIX_HALF_SIZE = MATRIX_SIZE / 2;
    const float SHAPE_SCALE_VALUE = VOXEL_REAL_SIZE; // results into 23.76x23.76x23.76 cm続 - in reality is 28x28x25 cm続
    static const int VOXELS_NUMBER = MATRIX_SIZE * MATRIX_SIZE *MATRIX_SIZE;
    constexpr static const float MATRIX_SIZE_M = MATRIX_SIZE * VOXEL_REAL_SIZE;

    static const short int EMPTYVOXEL = 0;
    static const short int FILLEDVOXEL = 255;

    unsigned int id;
    // Variables used to contain handles.
    std::vector<Organ> organList;
    int numSkeletonVoxels;
    Descriptors indDesc;
    std::vector<int> skeletonHandles;
    int gripperHandle;
};

}//sim

}//are

#endif //Morphology_CPPNMatrix_H
