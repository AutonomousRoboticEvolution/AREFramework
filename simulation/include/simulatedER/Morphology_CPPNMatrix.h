#ifndef Morphology_CPPNMatrix_H
#define Morphology_CPPNMatrix_H

#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/GenomeDecoder.h"
#include "ARE/Logging.h"

#include "PolyVox/RawVolume.h"
#include "PolyVox/MarchingCubesSurfaceExtractor.h"
#include "eigen3/Eigen/Core"
#include "ARE/morphology_descriptors.hpp"
#include "simulatedER/Blueprint.h"

#include "math.h"

using mc = are::morph_const;

namespace are {

namespace sim {

class Morphology_CPPNMatrix : public Morphology
{
public:
    Morphology_CPPNMatrix(const settings::ParametersMapPtr &param) : Morphology(param){
        matrix_4d.resize(0);
    }
    Morphology_CPPNMatrix(const Morphology_CPPNMatrix& mcm): Morphology(mcm),
        use_neat(mcm.use_neat),
        cppn(mcm.cppn),
        nn2_cppn(mcm.nn2_cppn),
        id(mcm.id),
        organList(mcm.organList),
        numSkeletonVoxels(mcm.numSkeletonVoxels),
        indDesc(mcm.indDesc),
        skeletonHandles(mcm.skeletonHandles),
        blueprint(mcm.blueprint),
        skeletonListVertices(mcm.skeletonListVertices),
        skeletonListIndices(mcm.skeletonListIndices),
        matrix_4d(mcm.matrix_4d){}

    class RobotManRes{
    public:
        bool noCollisions;
        bool noBadOrientations;
        bool isGripperAccess;
        // Constructor
        RobotManRes(){
            noCollisions = true;
            noBadOrientations = true;
            isGripperAccess = true;
        }
        std::vector<bool> getResVector() const{
            std::vector<bool> resVector;
            resVector.push_back(noCollisions);
            resVector.push_back(noBadOrientations);
            resVector.push_back(isGripperAccess);
            return resVector;
        }
    };
    RobotManRes robotManRes;

    are::Morphology::Ptr clone() const override
        {return std::make_shared<Morphology_CPPNMatrix>(*this);}

    void create() override;
    void createAtPosition(float,float,float) override;
    void setPosition(float,float,float);

    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper(std::vector<int> &gripperHandles);
    /**
     * @brief Takes the last three outputs of the network and converts them into rotations (radians) in x, y and z.
     * \todo EB: This method needs updating. Only one output required.
     */
    void setOrganOrientation(Organ& organ);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper(const std::vector<int> &gripperHandles);
    /**
     * @brief Removes all physical connector created with createTemporalConnector
     */
    void destroy_physical_connectors();
    /**
     * @brief This method tests that robot as a whole.
     */
    void testRobot(PolyVox::RawVolume<uint8_t>& skeletonMatrix);
    /**
     * @brief This method generates organs only in specific regions of the surface of the skeleton according to the cppn.
     */
    void generateOrgans(std::vector<std::vector<std::vector<int>>> &skeletonSurfaceCoord);
    /**
     * @brief This method generates the orientation of the organ accoriding to the "normal" of the surface
     * In reality, it takes the position of the last outer voxel. In other words, it generates orientations in
     * intervals of 45o.
     */
    void generateOrientations(int x, int y, int z, std::vector<float> &orientation);
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum);
    /**
     * @brief Retrieve matrices
     */
    void retrieve_matrices_from_cppn();
    /**
     * Returns the organ for the specific input organ coordinate.
     * @param input - coordinate
     * @return Organ type
     */
    int get_organ_from_cppn(std::vector<double> input);

    ///////////////////////////////
    ///// Setters and getters /////
    ///////////////////////////////
    std::vector<bool> getRobotManRes(){return robotManRes.getResVector();}
    const NEAT::NeuralNetwork &getNEATCPPN(){return cppn;}
    const nn2_cppn_t &getNN2CPPN(){return nn2_cppn;}

    void setNEATCPPN(const NEAT::NeuralNetwork &genome){
        use_neat = true;
        cppn = genome;
    }
    void setNN2CPPN(const nn2_cppn_t &nn){
        use_neat = false;
        nn2_cppn = nn;
    }

    void set_matrix_4d(const std::vector<std::vector<double>> m4d){matrix_4d = m4d;}

    Eigen::VectorXd getMorphDesc() const {
        int descriptor = settings::getParameter<settings::Integer>(parameters,"#descriptor").value;
        if(descriptor == CART_DESC)
            return indDesc.cartDesc.getCartDesc();
        else if(descriptor == ORGAN_POSITION)
            return indDesc.organDesc.getCartDesc();
        else std::cerr << "Morphology CPPN Matrix getMorphDesc: unknown descriptor type" << std::endl;
        return Eigen::VectorXd::Zero(1);
    }
    OrganPositionDesc getOrganPosDesc() const {return indDesc.organDesc;}
    CartDesc getCartDesc() const {return indDesc.cartDesc;}
    int get_wheelNumber() const {return indDesc.cartDesc.wheelNumber;}
    int get_jointNumber() const {return indDesc.cartDesc.jointNumber;}
    int get_sensorNumber() const {return indDesc.cartDesc.sensorNumber;}
    std::vector<int> getOrganTypes(){return blueprint.getOrganTypes();}
    std::vector<std::vector<float>> getOrganPosList(){return blueprint.getOrganPosList();}
    std::vector<std::vector<float>> getOrganOriList(){return blueprint.getOrganOriList();}
    const std::vector<float> &getSkeletonListVertices() const {return skeletonListVertices;}
    const std::vector<int> &getSkeletonListIndices() const {return skeletonListIndices;}
    const std::vector<std::vector<double>> &get_matrix_4d() const {return matrix_4d;}

private:
    ///////////////////////
    ///// Descriptors /////
    ///////////////////////

    class Descriptors
    {
    public:
        CartDesc cartDesc;
        OrganPositionDesc organDesc;
        void countOrgans(std::vector<Organ> organList){
            for(std::vector<Organ>::iterator it = organList.begin(); it != organList.end(); it++){
                if(!it->isOrganRemoved() && it->isOrganChecked()) {
                    if (it->getOrganType() == 1)
                        cartDesc.wheelNumber++;
                    if (it->getOrganType() == 2)
                        cartDesc.sensorNumber++;
                    if (it->getOrganType() == 3) {
                        cartDesc.jointNumber++;
                        cartDesc.jointNumber++;
                    }if (it->getOrganType() == 4)
                        cartDesc.casterNumber++;
                }

            }
        }
        void getRobotDimensions(std::vector<Organ> organList){
            float minX = 0, minY = 0, minZ = 0, maxX = 0, maxY = 0, maxZ = 0;
            for(auto & i : organList) {
                if (!i.isOrganRemoved() && i.isOrganChecked()) {
                    if(i.connectorPos.at(0) > maxX)
                        maxX = i.connectorPos.at(0);
                    if(i.connectorPos.at(1) > maxY)
                        maxY = i.connectorPos.at(1);
                    if(i.connectorPos.at(2) > maxZ)
                        maxZ = i.connectorPos.at(2);
                    if(i.connectorPos.at(0) < minX)
                        minX = i.connectorPos.at(0);
                    if(i.connectorPos.at(1) < minY)
                        minY = i.connectorPos.at(1);
                    if(i.connectorPos.at(2) < minZ)
                        minZ = i.connectorPos.at(2);
                }
            }
            // Get dimmensions
            cartDesc.robotWidth = fabs(maxX - minX);
            cartDesc.robotDepth = fabs(maxY - minY);
            cartDesc.robotHeight = fabs(maxZ - minZ);
        }
        void getOrganPositions(std::vector<Organ> organList){
            for(std::vector<Organ>::iterator it = organList.begin(); it != organList.end(); it++){
                if(!it->isOrganRemoved() && it->isOrganChecked()) {
                    int voxelPosX = static_cast<int>(std::round(it->connectorPos[0] / mc::voxel_real_size));
                    int voxelPosY = static_cast<int>(std::round(it->connectorPos[1] / mc::voxel_real_size));
                    int voxelPosZ = static_cast<int>(std::round(it->connectorPos[2] / mc::voxel_real_size));
                    int matPosX, matPosY, matPosZ;
                    matPosX = voxelPosX + 5;
                    matPosY = voxelPosY + 5;
                    matPosZ = voxelPosZ - 1; // The connector is slightly up and when rounding it increases one voxel.
                    if (matPosX > mc::real_matrix_size)
                        matPosX = mc::real_matrix_size;
                    if (matPosX < 0)
                        matPosX = 0;
                    if (matPosY > mc::real_matrix_size)
                        matPosY = mc::real_matrix_size;
                    if (matPosY < 0)
                        matPosY = 0;
                    if (matPosZ > mc::real_matrix_size)
                        matPosZ = mc::real_matrix_size;
                    if (matPosZ < 0)
                        matPosZ = 0;
                    organDesc.organ_matrix[matPosX][matPosY][matPosZ] = it->getOrganType();
                }
            }
        }
    };

public:
    //NEAT::Substrate get_substrate() { return substrate;}
    //void set_substrate(NEAT::Substrate sub){substrate = sub;}

private:
    bool use_neat=false;
    NEAT::NeuralNetwork cppn;
    nn2_cppn_t nn2_cppn;

    unsigned int id = 0;
    // Variables used to contain handles.
    std::vector<Organ> organList;
    int numSkeletonVoxels;
    Descriptors indDesc;
    std::vector<int> skeletonHandles;
    Blueprint blueprint;
    std::vector<float> skeletonListVertices;
    std::vector<int> skeletonListIndices;
    //NEAT::Substrate substrate;

    std::vector<std::vector<double>> matrix_4d;
    std::vector<std::vector<std::vector<int>>> skeletonSurfaceCoord;

};

}//sim

}//are

#endif //Morphology_CPPNMatrix_H
