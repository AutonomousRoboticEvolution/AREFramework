#ifndef Morphology_CPPNMatrix_H
#define Morphology_CPPNMatrix_H

#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/GenomeDecoder.h"
#include "ARE/Logging.h"

#include "PolyVox/RawVolume.h"
#include "PolyVox/MarchingCubesSurfaceExtractor.h"
#include "eigen3/Eigen/Core"
#include "ARE/morphology_descriptors.hpp"
#include "simulatedER/Blueprint.h"

#include "math.h"

namespace are {

namespace sim {

class Morphology_CPPNMatrix : public Morphology
{
public:
    Morphology_CPPNMatrix(const settings::ParametersMapPtr &param) : Morphology(param){}

    class RobotManRes{
    public:
        bool noCollisions;
        bool noBadOrientations;
        bool isGripperAccess;
        // Constructor
        RobotManRes(){
            noCollisions = true;
            noBadOrientations = true;
            isGripperAccess = true;
        }
        std::vector<bool> getResVector() const{
            std::vector<bool> resVector;
            resVector.push_back(noCollisions);
            resVector.push_back(noBadOrientations);
            resVector.push_back(isGripperAccess);
            return resVector;
        }
    };
    RobotManRes robotManRes;

    are::Morphology::Ptr clone() const override
        {return std::make_shared<Morphology_CPPNMatrix>(*this);}

    void create() override;
    void createAtPosition(float,float,float) override;
    void setPosition(float,float,float);

    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper();
    /**
     * @brief Takes the last three outputs of the network and converts them into rotations (radians) in x, y and z.
     * \todo EB: This method needs updating. Only one output required.
     */
    void setOrganOrientation(NEAT::NeuralNetwork &cppn, Organ& organ);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper();
    /**
     * @brief This method tests that robot as a whole.
     */
    void testRobot(PolyVox::RawVolume<uint8_t>& skeletonMatrix);
    /**
     * @brief This method generates organs only in specific regions of the surface of the skeleton according to the cppn.
     */
    void generateOrgans(NEAT::NeuralNetwork &cppn, std::vector<std::vector<std::vector<int>>> &skeletonSurfaceCoord);
    /**
     * @brief This method generates the orientation of the organ accoriding to the "normal" of the surface
     * In reality, it takes the position of the last outer voxel. In other words, it generates orientations in
     * intervals of 45o.
     */
    void generateOrientations(int x, int y, int z, std::vector<float> &orientation);
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum);

    ///////////////////////////////
    ///// Setters and getters /////
    ///////////////////////////////
    std::vector<bool> getRobotManRes() const {return robotManRes.getResVector();}
    const NEAT::NeuralNetwork &getGenome() const {return nn;}
    void setGenome(NEAT::NeuralNetwork genome){nn = genome;}
    Eigen::VectorXd getMorphDesc() const {return indDesc.cartDesc.getCartDesc();}
    const CartDesc& getCastDesc() const {return indDesc.cartDesc;}
    int get_wheelNumber() const {return indDesc.cartDesc.wheelNumber;}
    int get_jointNumber() const {return indDesc.cartDesc.jointNumber;}
    int get_sensorNumber() const {return indDesc.cartDesc.sensorNumber;}
    std::vector<int> getOrganTypes(){return blueprint.getOrganTypes();};
    std::vector<std::vector<float>> getOrganPosList(){return blueprint.getOrganPosList();};
    std::vector<std::vector<float>> getOrganOriList(){return blueprint.getOrganOriList();};
    const std::vector<float> &getSkeletonListVertices() const {return skeletonListVertices;}
    const std::vector<int> &getSkeletonListIndices() const {return skeletonListIndices;}

private:
    ///////////////////////
    ///// Descriptors /////
    ///////////////////////

    class Descriptors
    {
    public:
        CartDesc cartDesc;

        void countOrgans(std::vector<Organ> organList){
            for(std::vector<Organ>::iterator it = organList.begin(); it != organList.end(); it++){
                if(!it->isOrganRemoved() && it->isOrganChecked()) {
                    if (it->getOrganType() == 1)
                        cartDesc.wheelNumber++;
                    if (it->getOrganType() == 2)
                        cartDesc.sensorNumber++;
                    if (it->getOrganType() == 3)
                        cartDesc.jointNumber++;
                    if (it->getOrganType() == 4)
                        cartDesc.casterNumber++;
                }

            }
        }
        void getRobotDimensions(std::vector<Organ> organList){
            float minX = 0, minY = 0, minZ = 0, maxX = 0, maxY = 0, maxZ = 0;
            for(auto & i : organList) {
                if (!i.isOrganRemoved() && i.isOrganChecked()) {
                    if(i.connectorPos.at(0) > maxX)
                        maxX = i.connectorPos.at(0);
                    if(i.connectorPos.at(1) > maxY)
                        maxY = i.connectorPos.at(1);
                    if(i.connectorPos.at(2) > maxZ)
                        maxZ = i.connectorPos.at(2);
                    if(i.connectorPos.at(0) < minX)
                        minX = i.connectorPos.at(0);
                    if(i.connectorPos.at(1) < minY)
                        minY = i.connectorPos.at(1);
                    if(i.connectorPos.at(2) < minZ)
                        minZ = i.connectorPos.at(2);
                }
            }
            // Get dimmensions
            cartDesc.robotWidth = abs(maxX - minX);
            cartDesc.robotDepth = abs(maxY - minY);
            cartDesc.robotHeight = abs(maxZ - minZ);
        }
    };


    NEAT::NeuralNetwork nn;

    unsigned int id = 0;
    // Variables used to contain handles.
    std::vector<Organ> organList;
    int numSkeletonVoxels;
    Descriptors indDesc;
    std::vector<int> skeletonHandles;
    std::vector<int> gripperHandles;
    Blueprint blueprint;
    std::vector<float> skeletonListVertices;
    std::vector<int> skeletonListIndices;
};

}//sim

}//are

#endif //Morphology_CPPNMatrix_H
