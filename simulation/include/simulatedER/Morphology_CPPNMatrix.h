#ifndef Morphology_CPPNMatrix_H
#define Morphology_CPPNMatrix_H

#include <vector>

#include <PolyVox/RawVolume.h>
#include <PolyVox/MarchingCubesSurfaceExtractor.h>
#include <eigen3/Eigen/Core>

#include "ARE/Logging.h"
#include "simulatedER/Morphology.h"
#include "simulatedER/Organ.h"
#include "simulatedER/GenomeDecoder.h"
#include "simulatedER/morphology_constants.hpp"
#include "simulatedER/nn2/NN2CPPNGenome.hpp"
#include "simulatedER/nn2/sq_cppn_genome.hpp"
#include "simulatedER/morphology_descriptors.hpp"
#include "simulatedER/Blueprint.h"

#include "math.h"

using mc = are::morph_const;

namespace are {

typedef std::vector<std::vector<std::vector<int>>> matrix_int_t;

namespace sim {


class Morphology_CPPNMatrix : public Morphology
{
public:
    Morphology_CPPNMatrix(const settings::ParametersMapPtr &param) : Morphology(param){
    }
    Morphology_CPPNMatrix(const Morphology_CPPNMatrix& mcm): Morphology(mcm),
        nn2_cppn(mcm.nn2_cppn),
        id(mcm.id),
        organList(mcm.organList),
        numSkeletonVoxels(mcm.numSkeletonVoxels),
        feat_desc(mcm.feat_desc),
        organ_mat_desc(mcm.organ_mat_desc),
        matrix_desc(mcm.matrix_desc),
        skeletonHandles(mcm.skeletonHandles),
        blueprint(mcm.blueprint),
        skeletonListVertices(mcm.skeletonListVertices),
        skeletonListIndices(mcm.skeletonListIndices),
        matrix_4d(mcm.matrix_4d),
        quadric(mcm.quadric)
        {}

    ~Morphology_CPPNMatrix(){
    }

    class RobotManRes{
    public:
        bool noCollisions;
        bool noBadOrientations;
        bool isGripperAccess;
        // Constructor
        RobotManRes(){
            noCollisions = true;
            noBadOrientations = true;
            isGripperAccess = true;
        }
        std::vector<bool> getResVector() const{
            std::vector<bool> resVector;
            resVector.push_back(noCollisions);
            resVector.push_back(noBadOrientations);
            resVector.push_back(isGripperAccess);
            return resVector;
        }
    };
    RobotManRes robotManRes;

    are::Morphology::Ptr clone() const override
        {return std::make_shared<Morphology_CPPNMatrix>(*this);}

    void create() override;
    void createAtPosition(float,float,float) override;
    void setPosition(float,float,float);
    void load();

    bool convex_decomposition(int meshHandle, int numSkeletonVoxels, std::vector<int> &skeletonHandles);

    void check_repress_organs(const PolyVox::RawVolume<uint8_t> &skeletonMatrix, const std::vector<int> &gripperHandles);

    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     */
    bool getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh);
    /**
     * @brief Create the head organ. This should be the first organ created.
     */
    void createHead();
    /**
     * @brief Creates a temporal gripper. The isOrganColliding method checks this gripper is not colliding.
     */
    void createGripper(std::vector<int> &gripperHandles);
    /**
     * @brief Takes the last three outputs of the network and converts them into rotations (radians) in x, y and z.
     * \todo EB: This method needs updating. Only one output required.
     */
    void setOrganOrientation(Organ& organ);
    /**
     * @brief Removes the gripper created with createTemporalGripper
     */
    void destroyGripper(const std::vector<int> &gripperHandles);
    /**
     * @brief Removes all physical connector created with createTemporalConnector
     */
    void destroy_physical_connectors();
    /**
     * @brief This method tests that robot as a whole.
     */
    void testRobot();
    /**
     * @brief This method generates organs only in specific regions of the surface of the skeleton according to the cppn.
     */
    void generateOrgans(std::vector<std::vector<std::vector<int>>> &skeletonSurfaceCoord);
    /**
     * @brief This method generates the orientation of the organ accoriding to the "normal" of the surface
     * In reality, it takes the position of the last outer voxel. In other words, it generates orientations in
     * intervals of 45o.
     */
    void generateOrientations(int x, int y, int z, std::vector<float> &orientation);
    /**
     * @brief Export the robot as ttm model
     * \todo EB: We might not want this method here and this should be in logging instead.
     */
    void exportRobotModel(int indNum, const std::string &folder = Logging::log_folder);
    /**
     * @brief Retrieve matrices
     */
    void retrieve_matrices_from_cppn();
    /**
     * Returns the organ for the specific input organ coordinate.
     * @param input - coordinate
     * @return Organ type
     */
    int get_organ_from_cppn(std::vector<double> input);


    /**
     * @brief generate the skeleton matrix and organs_list from a list of coordinate and component type.
     * @param skeleton_matrix
     * @param organs_list
     * @param list_of_voxels obtained by using load_manual_design.
     */
    void generateFromManualDesign(skeleton_matrix_t &skeleton_matrix, std::vector<Organ> &organs_list, const std::vector<std::vector<int>> &list_of_voxels);

    /**
     * @brief Read a text file exported for goxel containing list of voxels with color values in hexa.
     *        ffffff white => 1 bone
     *        ff0000 red => 2 wheel
     *        00ff00 green => 3 sensor
     *        0000ff blue => 4 leg
     *        000000 black => 5 caster
     * @param filename
     * @param list_of_voxels
     */
    static void load_manual_design(const std::string& filename, std::vector<std::vector<int>> &list_of_voxels);

    ///////////////////////////////
    ///// Setters and getters /////
    ///////////////////////////////
    std::vector<bool> getRobotManRes(){return robotManRes.getResVector();}
    const nn2_cppn_t &getNN2CPPN(){return nn2_cppn;}


    void setNN2CPPN(const nn2_cppn_t &nn){
        nn2_cppn = nn;
    }
    void set_quadric(const quadric_t<quadric_mut_params> &quad){
        quadric = quad;
    }
    void set_matrix_4d(const std::vector<std::vector<double>> m4d){matrix_4d = m4d;}

    void setLoadRobot(){isRobotModel = true;}
    void setDecodeRobot(){isRobotModel = false;}

    Eigen::VectorXd getMorphDesc() const {
        int descriptor = settings::getParameter<settings::Integer>(parameters,"#descriptor").value;
        if(descriptor == FEATURES)
            return feat_desc.to_eigen_vector();
        else if(descriptor == ORGAN_POSITION)
            return organ_mat_desc.to_eigen_vector();
        else if(descriptor == MATRIX)
            return matrix_desc.to_eigen_vector();
        else std::cerr << "Morphology CPPN Matrix getMorphDesc: unknown descriptor type" << std::endl;
        return Eigen::VectorXd::Zero(1);
    }
    const OrganMatrixDesc &getOrganPosDesc() const {return organ_mat_desc;}
    const MatrixDesc &getMatrixDesc() const {return matrix_desc;}
    const FeaturesDesc &getFeatureDesc() const {return feat_desc;}
    int get_wheel_number() const {return feat_desc.wheel_number;}
    int get_joint_number() const {return feat_desc.joint_number;}
    int get_sensor_number() const {return feat_desc.sensor_number;}
    std::vector<int> getOrganTypes(){return blueprint.getOrganTypes();}
    std::vector<std::vector<float>> getOrganPosList(){return blueprint.getOrganPosList();}
    std::vector<std::vector<float>> getOrganOriList(){return blueprint.getOrganOriList();}
    const std::vector<double> &getSkeletonListVertices() const {return skeletonListVertices;}
    const std::vector<int> &getSkeletonListIndices() const {return skeletonListIndices;}
    const std::vector<std::vector<double>> &get_matrix_4d() const {return matrix_4d;}

    void set_list_of_voxels(const std::vector<std::vector<int>> &lov){list_of_voxels = lov;}



private:
    nn2_cppn_t nn2_cppn;
    quadric_t<quadric_mut_params> quadric;
    std::vector<std::vector<int>> list_of_voxels;

    unsigned int id = 0;
    // Variables used to contain handles.
    std::vector<Organ> organList;
    FeaturesDesc feat_desc;
    MatrixDesc matrix_desc;
    OrganMatrixDesc organ_mat_desc;
    int numSkeletonVoxels;
    std::vector<int> skeletonHandles;
    Blueprint blueprint;
    std::vector<double> skeletonListVertices;
    std::vector<int> skeletonListIndices;
    bool isRobotModel = 0;

    std::vector<std::vector<double>> matrix_4d;
    std::vector<std::vector<std::vector<int>>> skeletonSurfaceCoord;

};

}//sim

}//are

#endif //Morphology_CPPNMatrix_H
