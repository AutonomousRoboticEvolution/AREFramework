#pragma once
#ifndef EA_H
#define EA_H

#include <chrono>

//#include "Genome.h"
#include "ARE/Genome.h"
#include "ARE/Settings.h"
#include "ARE/exp_plugin_loader.hpp"
#include "ARE/Individual.h"
#include "ARE/Environment.h"


namespace are{

typedef std::chrono::high_resolution_clock hr_clock;

class EA
{
public:

    typedef std::unique_ptr<EA> Ptr;
    typedef std::unique_ptr<const EA> ConstPtr;
    typedef EA::Ptr (Factory)(const misc::RandNum::Ptr&,const settings::ParametersMapPtr&);

    EA(){}
    EA(const misc::RandNum::Ptr& rn, const settings::ParametersMapPtr& param);
    //non copyable object
//    EA(const EA& ea) :
//        settings(ea.settings),
//        randomNum(ea.randomNum),
//        populationGenomes(ea.populationGenomes),
//        population(ea.population),
//        createGenome(ea.createGenome),
//        neatSaveFile(ea.neatSaveFile),
//        popNextIndNumbers(ea.popNextIndNumbers),
//        nextGenGenomes(ea.nextGenGenomes)
//    {}
    virtual ~EA();


    /// This method sets the fitness value of an individual
    virtual void setObjectives(size_t indIndex, const std::vector<double> &objectives)
    {
        currentIndIndex = indIndex;
        population[indIndex]->setObjectives(objectives);
    }

    /**
     * @brief Update method is called after each evaluation of an individual.
     * @return If the algorithm can continue to the next ind
     */
    virtual bool update(const Environment::Ptr&)
    {
        numberEvaluation++;
        return true;
    }

    void incr_nbr_eval(){numberEvaluation++;}

    /**
     * @brief Initialisation of the algorithm. Called only one time on starting up
     */
    virtual void init() = 0;
    /**
     * @brief Epoch method is called at the end of each generation
     */
    virtual void epoch();
    /**
     * @brief Initialisation of the population for next generation. Called at the end of each generation after the epoch function.
     */
    virtual void init_next_pop();

    /**
     * @brief ending condition of the algorithm
     * @return true if ending condition is meet
     */
    virtual bool is_finish(){
        int maxGen = settings::getParameter<settings::Integer>(parameters,"#numberOfGeneration").value;
        return generation >= maxGen;
    }

    /**
     * @brief ending condition of the evaluation. This condition is added with OR to the default condition the time limit.
     * @return
     */
    virtual bool finish_eval(const Environment::Ptr& env){
        return false;
    }

    //Only for real experiements
    /**
     * @brief implementation of the function used to load the data for the update executable
     */
    virtual void load_data_for_update(){}

    /**
     * @brief implementation of the function used to load the data for the generate executable
     */
    virtual void load_data_for_generate(){}

    /**
     * @brief implementation of the function used to write the working data generated by the update executable
     */
    virtual void write_data_for_update(){}

    /**
     * @brief implementation of the function used to write the working data generated by the generate executable
     */
    virtual void write_data_for_generate(){}

    virtual void fill_ind_to_eval(std::vector<int> &ind_to_eval);

    //GETTERS & SETTERS
    void setCurrentIndIndex(int index){currentIndIndex = index;}
    virtual Individual::Ptr getIndividual(size_t index) const;
    virtual size_t get_pop_size() const {return population.size();}

    const std::vector<Individual::Ptr> &get_population() const {return population;}
    const settings::ParametersMapPtr &get_parameters() const {return parameters;}
    const misc::RandNum::Ptr get_randomNum() const {return randomNum;}
    void set_randomNum(const misc::RandNum::Ptr& rn){randomNum = rn;}
    void set_parameters(const settings::ParametersMapPtr& param){parameters = param;}
    void set_generation(int gen){generation = gen;}
    int get_generation() const {return generation;}
    void incr_generation(){generation++;}

    int get_numberEvaluation() const {return numberEvaluation;}

    void set_simulator_side(bool ss){simulator_side = ss;}

    virtual const Genome::Ptr get_next_controller_genome(int id) { return nullptr; } //method for the physical side

    std::vector<double> get_objectives(){return objectives;}
    void set_objectives(const std::vector<double>& objs){objectives = objs;}
    const std::vector<waypoint> &get_trajectory(){return trajectory;}
    void set_trajectory(const std::vector<waypoint> &traj){trajectory = traj;}

protected:
    /// This method initilizes a population of genomes
    virtual void evaluation(){} // This is now only used by NEAT but can also be done for the other genomes. However, by passing the update function to the EA different EA objects can contain different scenarios making the plugin more flexible.
    virtual void selection(){}  // selection operator
    virtual void replacement(){}// replacement operator
    virtual void mutation(){}   // mutation operator
    virtual void crossover(){}  // crossover
    virtual void end(){}		// last call to the EA, when simulation stops

    std::vector<Individual::Ptr> population;
    ///set the environment type, evolution type...
    settings::ParametersMapPtr parameters;
    ///random number generator for EA
    misc::RandNum::Ptr randomNum;
    std::vector<double> objectives; //current objectives values (used in hardware evolution)
    std::vector<waypoint> trajectory; //current trajectory (used in hardware evolution)

    int generation = 0;
    int numberEvaluation = 0;
    bool simulator_side = true;
    int currentIndIndex = 0;
};

}//are

#endif //EA_H
