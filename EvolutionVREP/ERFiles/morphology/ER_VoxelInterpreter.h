/**
	@file ER_VoxelInterpreter.h
    @authors Edgar Buchanan and Matteo de Carlo
	@brief This class decodes the genome (CPPN) and generated the phenotype (matrix morphology)
*/
#pragma once

#include "EvolvedMorphology.h"
#include "PolyVox/RawVolume.h"
#include "PolyVox/MarchingCubesSurfaceExtractor.h"

class ER_VoxelInterpreter : public EvolvedMorphology
{
public:
    ER_VoxelInterpreter(unsigned int id);
    ~ER_VoxelInterpreter();

    /**
     * @brief This class creates the morphology
     * @param neuralNetwork - Genome generated by Multi-NEAT
     * @param decompose
     */
    void init(NEAT::NeuralNetwork &neuralNetwork, bool decompose = true);
    /**
     * @brief This class mutates the controller
     * \todo This class might not be used if controller is not within the morphology
     */
    void mutate() override;
    /**
     * @brief This class should read sensors and send signals to sensors.
     * \todo Class empty!
     */
    void update() override;
    /**
     * @brief This class is suppose to generate the morphology.
     * \todo Class empty!
     */
    void create() override;

    struct AREVoxel{
        uint8_t bone;
        uint8_t wheel;
    };

    /**
     * @brief Decodes the genome (CPPN --> Matrix)
     * @param areMatrix Matrix of voxels. This matrix includes all types: bones, wheels, sensors, etc.
     * @param cppn CPPN generated by NEAT
     */
    void genomeDecoder(PolyVox::RawVolume<AREVoxel>& areMatrix, NEAT::NeuralNetwork &cppn);
    /**
     * @brief Export mesh file (stl) from a list of vertices and indices.
     * @param vertices
     * @param indices
     */
    void exportMesh(std::vector<simFloat> vertices, std::vector<simInt> indices);
    /// Get indices and vertices from mesh file
    /**
     * @brief This method gets all the verices and indices of the mesh generated by PolyVox.
     * This list is imported to V-REP.
     * @param decodedMesh Mesh generated by PolyVox
     * @param vertices
     * @param indices
     */
    void getIndicesVertices(PolyVox::Mesh<PolyVox::Vertex<uint8_t>>& decodedMesh, std::vector<simFloat>& vertices, std::vector<simInt>& indices);

    /// Voxel-matrix post-processing methods.
    /**
     * @brief This method generates the complete skeleton without alterations of the robot from the matrix of voxels.
     * \todo This method might not be necessary!
     * @param areMatrix
     * @param skeletonMatrix
     */
    void generateSkeleton(PolyVox::RawVolume<AREVoxel>& areMatrix, PolyVox::RawVolume<uint8_t>& skeletonMatrix); /// Generate complete skeleton (without alterations)
    /**
     * @brief This methods makes space for the Head Organ by removing voxels.
     * @param skeletonMatrix Skeleton Matrix
     * \todo Define skeleton matrix
     */
    void emptySpaceForHead(PolyVox::RawVolume<uint8_t>& skeletonMatrix);
    /**
     * Counts the number of regions in the matrix, or in other words, how many blobs are in the matrix
     * @param areMatrix Skeleton matrix
     */
    void regionCounter(PolyVox::RawVolume<AREVoxel>& areMatrix);
    /**
     * @brief Explores the neighbourhood until no more voxels are found of a specific type.
     * @param areMatrix
     * @param visitedVoxels
     * @param posX
     * @param posY
     * @param posZ
     */
    void exploration(PolyVox::RawVolume<AREVoxel>& areMatrix, PolyVox::RawVolume<bool>& visitedVoxels, int32_t posX, int32_t posY, int32_t posZ, AREVoxel areVoxel);
    /**
     * @brief Return the pointer of the morphology
     * @return Morphology share point
     * \todo Class empty!
     */
    std::shared_ptr<Morphology> clone();
    /**
     * @brief Gets main handle.
     * @return
     */
    int getMainHandle() override;

    //TODO size of this region should be the size of the printing bed, with resolution as a multiple of 0.9mm per block
    const float VOXEL_SIZE = 0.0009; //m³ - 0.9mm³
    const int VOXEL_MULTIPLIER = 4; // voxel of 3.4cm³
    const float VOXEL_REAL_SIZE = VOXEL_SIZE * static_cast<float>(VOXEL_MULTIPLIER); // voxel of 3.4cm³
    const int MATRIX_SIZE = (264 / VOXEL_MULTIPLIER); // 66
    const int MATRIX_HALF_SIZE = MATRIX_SIZE / 2; // 33

    // results into 23.76x23.76x23.76 cm³ - in reality is 28x28x25 cm³
    const simFloat SHAPE_SCALE_VALUE = VOXEL_REAL_SIZE;

private:
    unsigned int id;
};